CONST INT g_c_int1 1
CONST CHAR g_c_charf 'f'
CONST CHAR g_c_chara 'a'
CONST CHAR _0b 'b'
CONST INT _c_int2 2
CONST INT _g_10 3
INT G_v_int_a1
INT g_V_INT10_arr1[15]
INT tag[20]
CHAR g_v_char_h
INT g_v_int_arr2[10]
INT g_v_int_b
CHAR g_v_char_b
CHAR g_v_char_arr[50]
CHAR chs[5]
GOTO main
FUNC foo1
#0 = 0 - 1
RET #0
FUNC foo2
PARA a
PARA b
#0 = a + b
RET #0
FUNC add
PARA a
PARA b
#0 = a + b
RET #0
FUNC addchar
PARA a
PARA b
#0 = a + b
RET #0
FUNC addone
PARA a
#0 = a + 1
RET #0
FUNC addint
PARA a
#0 = a + 1
RET #0
FUNC foo3
PARA c
#0 = c > 'c'
BNZ #0 #LABEL0
RET '/'
GOTO #LABEL1
SET #LABEL0
RET '*'
SET #LABEL1
FUNC test_string_int
INT a
a = 1
OUTV a
a = 0
OUTV a
#0 = 0 + 0
a = #0
OUTV a
#1 = 0 - 0
a = #1
OUTV a
#2 = 0 + 12
a = #2
OUTV a
#3 = 0 - 12
a = #3
OUTV a
OUTS #$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~ !
RET #
FUNC fib
PARA n
#0 = n == 1
BNZ #0 #LABEL2
RET 1
GOTO #LABEL3
SET #LABEL2
SET #LABEL3
#1 = n == 2
BNZ #1 #LABEL4
RET 1
GOTO #LABEL5
SET #LABEL4
SET #LABEL5
#2 = n - 1
PUSH #2
CALL fib
#3 = #RET
#4 = n - 2
PUSH #4
CALL fib
#5 = #RET
#6 = #3 + #5
RET #6
FUNC test_all_cond
INT a
INT b
INT c
CHAR d
a = 1
b = 2
c = 2
d = 'A'
OUTS test of comp symbol
#0 = b == c
BNZ #0 #LABEL6
OUTS a==b
GOTO #LABEL7
SET #LABEL6
SET #LABEL7
#1 = a < b
BNZ #1 #LABEL8
OUTS a<b
GOTO #LABEL9
SET #LABEL8
SET #LABEL9
#2 = c > a
BNZ #2 #LABEL10
OUTS c>a
GOTO #LABEL11
SET #LABEL10
SET #LABEL11
#3 = d != 0
BNZ #3 #LABEL12
OUTS d
GOTO #LABEL13
SET #LABEL12
SET #LABEL13
#4 = a == 1
BNZ #4 #LABEL14
OUTS error!!
GOTO #LABEL15
SET #LABEL14
SET #LABEL15
#5 = a != 1
BNZ #5 #LABEL16
OUTS error
GOTO #LABEL17
SET #LABEL16
SET #LABEL17
#6 = a <= c
BNZ #6 #LABEL18
OUTS a<=c
GOTO #LABEL19
SET #LABEL18
SET #LABEL19
#7 = a >= c
BNZ #7 #LABEL20
OUTS error!
GOTO #LABEL21
SET #LABEL20
SET #LABEL21
#8 = d > 66
BNZ #8 #LABEL22
OUTS error!
GOTO #LABEL23
SET #LABEL22
SET #LABEL23
RET #
FUNC test_diff_domain
CONST CHAR g_c_chara 'b'
INT G_v_int_a1
OUTC g_c_chara
G_v_int_a1 = 222
OUTV G_v_int_a1
RET #
FUNC test_expr
INT res_of_expr
arr[1] = 1
OUTS test for expression
#0 = 0 - -12
#1 = #0 - -12
#2 = #1 - -12
#3 = #2 - 12
#4 = #3 + -12
#5 = #4 - -12
#6 = #5 - -12
#7 = #6 - -12
#8 = #7 - -12
res_of_expr = #8
OUTS --12--12--12-+12+-12--12--12--12--12=
OUTV res_of_expr
#9 = 10 * -5
res_of_expr = #9
OUTS 10*-5=
OUTV res_of_expr
#10 = 10 / 4
res_of_expr = #10
OUTS 10/+4=
OUTV res_of_expr
PUSH 12
CALL fib
#11 = #RET
PUSH 14
CALL fib
#12 = #RET
#13 = #11 - #12
res_of_expr = #13
OUTS fib(12)-fib(14)=
OUTV res_of_expr
#14 = 'c' + 12
res_of_expr = #14
OUTS c + 12 = 
OUTV res_of_expr
#15 = 'c' * 12
#16 = #15 / 1
res_of_expr = #16
OUTS c*12/1
OUTV res_of_expr
#17 = 12 + 1
#18 = 1 - #17
res_of_expr = #18
OUTS 1-(((12+1)))
OUTV res_of_expr
#19 = arr[1]
#20 = #19 * 'b'
PUSH 3
CALL fib
#21 = #RET
#22 = #20 + #21
res_of_expr = #22
OUTS arr[1]*'b'+fib(3)=
OUTV res_of_expr
G_v_int_a1 = 5
tag[6] = 12
g_v_char_h = 'h'
PUSH 'h'
CALL addone
#23 = #RET
PUSH 5
CALL fib
#24 = #RET
PUSH 1
PUSH #24
CALL add
#25 = #RET
#26 = #25 / G_v_int_a1
#27 = #23 + #26
#28 = tag[6]
#29 = #27 - #28
res_of_expr = #29
OUTS addone('h')+add(1, fib(5))/G_v_int_a1 - tag[6]=
OUTV res_of_expr
RET #
FUNC test_scanf
INT a
INT b
IN a
OUTV a
IN a
IN b
OUTV a
OUTV b
RET #
FUNC echo_char
PARA a
OUTC a
RET a
FUNC really_void
RET #
FUNC really_void2
RET #
FUNC really_void3
RET #
FUNC echo
PARA a
OUTS a=
OUTV a
RET #
FUNC permutation
PARA m
PARA n
INT i
CHAR t
CHAR r
#0 = n - 1
#1 = m < #0
BNZ #1 #LABEL24
#2 = m + 1
PUSH #2
PUSH n
CALL permutation
#3 = m + 1
i = #3
SET #LABEL26
#4 = i < n
BNZ #4 #LABEL27
#5 = chs[m]
t = #5
#6 = chs[i]
chs[m] = #6
chs[i] = t
#7 = m + 1
PUSH #7
PUSH n
CALL permutation
#8 = chs[m]
t = #8
#9 = chs[i]
chs[m] = #9
chs[i] = t
i = i + 1
GOTO #LABEL26
SET #LABEL27
GOTO #LABEL25
SET #LABEL24
i = 0
SET #LABEL28
#10 = chs[i]
PUSH #10
CALL echo_char
#11 = #RET
r = #11
#12 = chs[i]
#13 = r != #12
BNZ #13 #LABEL29
OUTS error
GOTO #LABEL30
SET #LABEL29
SET #LABEL30
#14 = i + 1
i = #14
#15 = i < 5
BEZ #15 #LABEL28
OUTS  
SET #LABEL25
RET #
FUNC main
CONST INT len 10
INT i
INT user_input1
INT user_input2
INT res_of_expr
i = 0
SET #LABEL31
#16 = i < len
BNZ #16 #LABEL32
#17 = i + 1
PUSH #17
CALL fib
#18 = #RET
arr[i] = #18
i = i + 1
GOTO #LABEL31
SET #LABEL32
OUTS input the number of fib you want(1~10)
IN user_input1
IN user_input2
i = user_input1
SET #LABEL33
OUTS  
#19 = arr[i]
OUTV #19
#20 = i + 1
i = #20
#21 = i <= user_input2
BEZ #21 #LABEL33
i = user_input2
SET #LABEL34
#22 = i >= user_input1
BNZ #22 #LABEL35
OUTS  
#23 = arr[i]
OUTV #23
i = i - 1
GOTO #LABEL34
SET #LABEL35
CALL foo1
#24 = #RET
OUTV #24
PUSH 1
PUSH 'b'
CALL foo2
#25 = #RET
OUTV #25
#26 = 0 + 2
PUSH 1
PUSH #26
CALL add
#27 = #RET
OUTV #27
PUSH 'a'
PUSH 'b'
CALL addchar
#28 = #RET
OUTV #28
PUSH 'F'
CALL addone
#29 = #RET
OUTV #29
PUSH 16
CALL addint
#30 = #RET
OUTV #30
PUSH 'c'
CALL foo3
#31 = #RET
OUTC #31
CALL test_string_int
CALL test_diff_domain
CALL test_expr
CALL test_all_cond
CALL test_scanf
PUSH 'a'
CALL echo_char
PUSH 5
CALL echo
CALL really_void
CALL really_void2
CALL really_void3
chs[0] = 'A'
chs[1] = 'B'
chs[2] = 'C'
chs[3] = 'D'
chs[4] = 'E'
PUSH 0
PUSH 5
CALL permutation
RET #
EXIT